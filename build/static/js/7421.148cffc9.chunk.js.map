{"version":3,"file":"static/js/7421.148cffc9.chunk.js","mappings":"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","sources":["../node_modules/@mui/material/CircularProgress/circularProgressClasses.js","../node_modules/@mui/material/CircularProgress/CircularProgress.js","../node_modules/qr-scanner/src/qr-scanner.ts","../node_modules/react-select-country-list/country-list.js","../node_modules/@apollo/src/react/hooks/useMutation.ts"],"sourcesContent":["import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getCircularProgressUtilityClass(slot) {\n  return generateUtilityClass('MuiCircularProgress', slot);\n}\nconst circularProgressClasses = generateUtilityClasses('MuiCircularProgress', ['root', 'determinate', 'indeterminate', 'colorPrimary', 'colorSecondary', 'svg', 'circle', 'circleDeterminate', 'circleIndeterminate', 'circleDisableShrink']);\nexport default circularProgressClasses;","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"className\", \"color\", \"disableShrink\", \"size\", \"style\", \"thickness\", \"value\", \"variant\"];\nlet _ = t => t,\n  _t,\n  _t2,\n  _t3,\n  _t4;\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport chainPropTypes from '@mui/utils/chainPropTypes';\nimport composeClasses from '@mui/utils/composeClasses';\nimport { keyframes, css } from '@mui/system';\nimport capitalize from '../utils/capitalize';\nimport useThemeProps from '../styles/useThemeProps';\nimport styled from '../styles/styled';\nimport { getCircularProgressUtilityClass } from './circularProgressClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst SIZE = 44;\nconst circularRotateKeyframe = keyframes(_t || (_t = _`\n  0% {\n    transform: rotate(0deg);\n  }\n\n  100% {\n    transform: rotate(360deg);\n  }\n`));\nconst circularDashKeyframe = keyframes(_t2 || (_t2 = _`\n  0% {\n    stroke-dasharray: 1px, 200px;\n    stroke-dashoffset: 0;\n  }\n\n  50% {\n    stroke-dasharray: 100px, 200px;\n    stroke-dashoffset: -15px;\n  }\n\n  100% {\n    stroke-dasharray: 100px, 200px;\n    stroke-dashoffset: -125px;\n  }\n`));\nconst useUtilityClasses = ownerState => {\n  const {\n    classes,\n    variant,\n    color,\n    disableShrink\n  } = ownerState;\n  const slots = {\n    root: ['root', variant, `color${capitalize(color)}`],\n    svg: ['svg'],\n    circle: ['circle', `circle${capitalize(variant)}`, disableShrink && 'circleDisableShrink']\n  };\n  return composeClasses(slots, getCircularProgressUtilityClass, classes);\n};\nconst CircularProgressRoot = styled('span', {\n  name: 'MuiCircularProgress',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, styles[ownerState.variant], styles[`color${capitalize(ownerState.color)}`]];\n  }\n})(({\n  ownerState,\n  theme\n}) => _extends({\n  display: 'inline-block'\n}, ownerState.variant === 'determinate' && {\n  transition: theme.transitions.create('transform')\n}, ownerState.color !== 'inherit' && {\n  color: (theme.vars || theme).palette[ownerState.color].main\n}), ({\n  ownerState\n}) => ownerState.variant === 'indeterminate' && css(_t3 || (_t3 = _`\n      animation: ${0} 1.4s linear infinite;\n    `), circularRotateKeyframe));\nconst CircularProgressSVG = styled('svg', {\n  name: 'MuiCircularProgress',\n  slot: 'Svg',\n  overridesResolver: (props, styles) => styles.svg\n})({\n  display: 'block' // Keeps the progress centered\n});\nconst CircularProgressCircle = styled('circle', {\n  name: 'MuiCircularProgress',\n  slot: 'Circle',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.circle, styles[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles.circleDisableShrink];\n  }\n})(({\n  ownerState,\n  theme\n}) => _extends({\n  stroke: 'currentColor'\n}, ownerState.variant === 'determinate' && {\n  transition: theme.transitions.create('stroke-dashoffset')\n}, ownerState.variant === 'indeterminate' && {\n  // Some default value that looks fine waiting for the animation to kicks in.\n  strokeDasharray: '80px, 200px',\n  strokeDashoffset: 0 // Add the unit to fix a Edge 16 and below bug.\n}), ({\n  ownerState\n}) => ownerState.variant === 'indeterminate' && !ownerState.disableShrink && css(_t4 || (_t4 = _`\n      animation: ${0} 1.4s ease-in-out infinite;\n    `), circularDashKeyframe));\n\n/**\n * ## ARIA\n *\n * If the progress bar is describing the loading progress of a particular region of a page,\n * you should use `aria-describedby` to point to the progress bar, and set the `aria-busy`\n * attribute to `true` on that region until it has finished loading.\n */\nconst CircularProgress = /*#__PURE__*/React.forwardRef(function CircularProgress(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiCircularProgress'\n  });\n  const {\n      className,\n      color = 'primary',\n      disableShrink = false,\n      size = 40,\n      style,\n      thickness = 3.6,\n      value = 0,\n      variant = 'indeterminate'\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const ownerState = _extends({}, props, {\n    color,\n    disableShrink,\n    size,\n    thickness,\n    value,\n    variant\n  });\n  const classes = useUtilityClasses(ownerState);\n  const circleStyle = {};\n  const rootStyle = {};\n  const rootProps = {};\n  if (variant === 'determinate') {\n    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);\n    circleStyle.strokeDasharray = circumference.toFixed(3);\n    rootProps['aria-valuenow'] = Math.round(value);\n    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;\n    rootStyle.transform = 'rotate(-90deg)';\n  }\n  return /*#__PURE__*/_jsx(CircularProgressRoot, _extends({\n    className: clsx(classes.root, className),\n    style: _extends({\n      width: size,\n      height: size\n    }, rootStyle, style),\n    ownerState: ownerState,\n    ref: ref,\n    role: \"progressbar\"\n  }, rootProps, other, {\n    children: /*#__PURE__*/_jsx(CircularProgressSVG, {\n      className: classes.svg,\n      ownerState: ownerState,\n      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,\n      children: /*#__PURE__*/_jsx(CircularProgressCircle, {\n        className: classes.circle,\n        style: circleStyle,\n        ownerState: ownerState,\n        cx: SIZE,\n        cy: SIZE,\n        r: (SIZE - thickness) / 2,\n        fill: \"none\",\n        strokeWidth: thickness\n      })\n    })\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? CircularProgress.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'primary'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['inherit', 'primary', 'secondary', 'error', 'info', 'success', 'warning']), PropTypes.string]),\n  /**\n   * If `true`, the shrink animation is disabled.\n   * This only works if variant is `indeterminate`.\n   * @default false\n   */\n  disableShrink: chainPropTypes(PropTypes.bool, props => {\n    if (props.disableShrink && props.variant && props.variant !== 'indeterminate') {\n      return new Error('MUI: You have provided the `disableShrink` prop ' + 'with a variant other than `indeterminate`. This will have no effect.');\n    }\n    return null;\n  }),\n  /**\n   * The size of the component.\n   * If using a number, the pixel unit is assumed.\n   * If using a string, you need to provide the CSS unit, for example '3rem'.\n   * @default 40\n   */\n  size: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  /**\n   * @ignore\n   */\n  style: PropTypes.object,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The thickness of the circle.\n   * @default 3.6\n   */\n  thickness: PropTypes.number,\n  /**\n   * The value of the progress indicator for the determinate variant.\n   * Value between 0 and 100.\n   * @default 0\n   */\n  value: PropTypes.number,\n  /**\n   * The variant to use.\n   * Use indeterminate when there is no progress value.\n   * @default 'indeterminate'\n   */\n  variant: PropTypes.oneOf(['determinate', 'indeterminate'])\n} : void 0;\nexport default CircularProgress;","class QrScanner {\n    static readonly DEFAULT_CANVAS_SIZE = 400;\n    static readonly NO_QR_CODE_FOUND = 'No QR code found';\n    private static _disableBarcodeDetector = false;\n    private static _workerMessageId = 0;\n\n    /** @deprecated */\n    static set WORKER_PATH(workerPath: string) {\n        console.warn('Setting QrScanner.WORKER_PATH is not required and not supported anymore. '\n            + 'Have a look at the README for new setup instructions.');\n    }\n\n    static async hasCamera(): Promise<boolean> {\n        try {\n            return !!(await QrScanner.listCameras(false)).length;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    static async listCameras(requestLabels = false): Promise<Array<QrScanner.Camera>> {\n        if (!navigator.mediaDevices) return [];\n\n        const enumerateCameras = async (): Promise<Array<MediaDeviceInfo>> =>\n            (await navigator.mediaDevices.enumerateDevices()).filter((device) => device.kind === 'videoinput');\n\n        // Note that enumerateDevices can always be called and does not prompt the user for permission.\n        // However, enumerateDevices only includes device labels if served via https and an active media stream exists\n        // or permission to access the camera was given. Therefore, if we're not getting labels but labels are requested\n        // ask for camera permission by opening a stream.\n        let openedStream: MediaStream | undefined;\n        try {\n            if (requestLabels && (await enumerateCameras()).every((camera) => !camera.label)) {\n                openedStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });\n            }\n        } catch (e) {\n            // Fail gracefully, especially if the device has no camera or on mobile when the camera is already in use\n            // and some browsers disallow a second stream.\n        }\n\n        try {\n            return (await enumerateCameras()).map((camera, i) => ({\n                id: camera.deviceId,\n                label: camera.label || (i === 0 ? 'Default Camera' : `Camera ${i + 1}`),\n            }));\n        } finally {\n            // close the stream we just opened for getting camera access for listing the device labels\n            if (openedStream) {\n                console.warn('Call listCameras after successfully starting a QR scanner to avoid creating '\n                    + 'a temporary video stream');\n                QrScanner._stopVideoStream(openedStream);\n            }\n        }\n    }\n\n    readonly $video: HTMLVideoElement;\n    readonly $canvas: HTMLCanvasElement;\n    readonly $overlay?: HTMLDivElement;\n    private readonly $codeOutlineHighlight?: SVGSVGElement;\n    private readonly _onDecode?: (result: QrScanner.ScanResult) => void;\n    private readonly _legacyOnDecode?: (result: string) => void;\n    private readonly _legacyCanvasSize: number = QrScanner.DEFAULT_CANVAS_SIZE;\n    private _preferredCamera: QrScanner.FacingMode | QrScanner.DeviceId = 'environment';\n    private readonly _maxScansPerSecond: number = 25;\n    private _lastScanTimestamp: number = -1;\n    private _scanRegion: QrScanner.ScanRegion;\n    private _codeOutlineHighlightRemovalTimeout?: number;\n    private _qrEnginePromise: Promise<Worker | BarcodeDetector>\n    private _active: boolean = false;\n    private _paused: boolean = false;\n    private _flashOn: boolean = false;\n    private _destroyed: boolean = false;\n\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: QrScanner.ScanResult) => void,\n        options: {\n            onDecodeError?: (error: Error | string) => void,\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n            maxScansPerSecond?: number;\n            highlightScanRegion?: boolean,\n            highlightCodeOutline?: boolean,\n            overlay?: HTMLDivElement,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n    );\n    /** @deprecated */\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        canvasSize?: number,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(video: HTMLVideoElement, onDecode: (result: string) => void, canvasSize?: number);\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: ((result: QrScanner.ScanResult) => void) | ((result: string) => void),\n        canvasSizeOrOnDecodeErrorOrOptions?: number | ((error: Error | string) => void) | {\n            onDecodeError?: (error: Error | string) => void,\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n            maxScansPerSecond?: number;\n            highlightScanRegion?: boolean,\n            highlightCodeOutline?: boolean,\n            overlay?: HTMLDivElement,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n        canvasSizeOrCalculateScanRegion?: number | ((video: HTMLVideoElement) => QrScanner.ScanRegion),\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    ) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n\n        if (canvasSizeOrOnDecodeErrorOrOptions && typeof canvasSizeOrOnDecodeErrorOrOptions === 'object') {\n            // we got an options object using the new api\n            this._onDecode = onDecode as QrScanner['_onDecode'];\n        } else {\n            if (canvasSizeOrOnDecodeErrorOrOptions || canvasSizeOrCalculateScanRegion || preferredCamera) {\n                console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                    + 'the future');\n            } else {\n                // Only video and onDecode were specified and we can't distinguish between new or old api usage. For\n                // backwards compatibility we have to assume the old api for now. The options object is marked as non-\n                // optional in the parameter list above to make clear that ScanResult instead of string is only passed\n                // if an options object was provided. However, in the future once legacy support is removed, the options\n                // object should become optional.\n                console.warn('Note that the type of the scan result passed to onDecode will change in the future. '\n                    + 'To already switch to the new api today, you can pass returnDetailedScanResult: true.');\n            }\n            this._legacyOnDecode = onDecode as QrScanner['_legacyOnDecode'];\n        }\n\n        const options = typeof canvasSizeOrOnDecodeErrorOrOptions === 'object'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : {};\n        this._onDecodeError = options.onDecodeError || (typeof canvasSizeOrOnDecodeErrorOrOptions === 'function'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : this._onDecodeError);\n        this._calculateScanRegion = options.calculateScanRegion || (typeof canvasSizeOrCalculateScanRegion==='function'\n            ? canvasSizeOrCalculateScanRegion\n            : this._calculateScanRegion);\n        this._preferredCamera = options.preferredCamera || preferredCamera || this._preferredCamera;\n        this._legacyCanvasSize = typeof canvasSizeOrOnDecodeErrorOrOptions === 'number'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : typeof canvasSizeOrCalculateScanRegion === 'number'\n                ? canvasSizeOrCalculateScanRegion\n                : this._legacyCanvasSize;\n        this._maxScansPerSecond = options.maxScansPerSecond || this._maxScansPerSecond;\n\n        this._onPlay = this._onPlay.bind(this);\n        this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n        this._updateOverlay = this._updateOverlay.bind(this);\n\n        // @ts-ignore\n        video.disablePictureInPicture = true;\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        // @ts-ignore\n        video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        video.muted = true;\n\n        // Avoid Safari stopping the video stream on a hidden video.\n        // See https://github.com/cozmo/jsQR/issues/185\n        let shouldHideVideo = false;\n        if (video.hidden) {\n            video.hidden = false;\n            shouldHideVideo = true;\n        }\n        if (!document.body.contains(video)) {\n            document.body.appendChild(video);\n            shouldHideVideo = true;\n        }\n        const videoContainer = video.parentElement!;\n\n        if (options.highlightScanRegion || options.highlightCodeOutline) {\n            const gotExternalOverlay = !!options.overlay;\n            this.$overlay = options.overlay || document.createElement('div');\n            const overlayStyle = this.$overlay.style;\n            overlayStyle.position = 'absolute';\n            overlayStyle.display = 'none';\n            overlayStyle.pointerEvents = 'none';\n            this.$overlay.classList.add('scan-region-highlight');\n            if (!gotExternalOverlay && options.highlightScanRegion) {\n                // default style; can be overwritten via css, e.g. by changing the svg's stroke color, hiding the\n                // .scan-region-highlight-svg, setting a border, outline, background, etc.\n                this.$overlay.innerHTML = '<svg class=\"scan-region-highlight-svg\" viewBox=\"0 0 238 238\" '\n                    + 'preserveAspectRatio=\"none\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;'\n                    + 'fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round\">'\n                    + '<path d=\"M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 '\n                    + '0H10a8 8 0 0 1-8-8v-21\"/></svg>';\n                try {\n                    this.$overlay.firstElementChild!.animate({ transform: ['scale(.98)', 'scale(1.01)'] }, {\n                        duration: 400,\n                        iterations: Infinity,\n                        direction: 'alternate',\n                        easing: 'ease-in-out',\n                    });\n                } catch (e) {}\n                videoContainer.insertBefore(this.$overlay, this.$video.nextSibling);\n            }\n            if (options.highlightCodeOutline) {\n                // default style; can be overwritten via css\n                this.$overlay.insertAdjacentHTML(\n                    'beforeend',\n                    '<svg class=\"code-outline-highlight\" preserveAspectRatio=\"none\" style=\"display:none;width:100%;'\n                        + 'height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;'\n                        + 'stroke-linecap:round;stroke-linejoin:round\"><polygon/></svg>',\n                );\n                this.$codeOutlineHighlight = this.$overlay.lastElementChild as SVGSVGElement;\n            }\n        }\n        this._scanRegion = this._calculateScanRegion(video);\n\n        requestAnimationFrame(() => {\n            // Checking in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle.\n            const videoStyle = window.getComputedStyle(video);\n            if (videoStyle.display === 'none') {\n                video.style.setProperty('display', 'block', 'important');\n                shouldHideVideo = true;\n            }\n            if (videoStyle.visibility !== 'visible') {\n                video.style.setProperty('visibility', 'visible', 'important');\n                shouldHideVideo = true;\n            }\n            if (shouldHideVideo) {\n                // Hide the video in a way that doesn't cause Safari to stop the playback.\n                console.warn('QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.');\n                video.style.opacity = '0';\n                video.style.width = '0';\n                video.style.height = '0';\n                if (this.$overlay && this.$overlay.parentElement) {\n                    this.$overlay.parentElement.removeChild(this.$overlay);\n                }\n                // @ts-ignore\n                delete this.$overlay!;\n                // @ts-ignore\n                delete this.$codeOutlineHighlight!;\n            }\n\n            if (this.$overlay) {\n                this._updateOverlay();\n            }\n        });\n\n        video.addEventListener('play', this._onPlay);\n        video.addEventListener('loadedmetadata', this._onLoadedMetaData);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n        window.addEventListener('resize', this._updateOverlay);\n\n        this._qrEnginePromise = QrScanner.createQrEngine();\n    }\n\n    async hasFlash(): Promise<boolean> {\n        let stream: MediaStream | undefined;\n        try {\n            if (this.$video.srcObject) {\n                if (!(this.$video.srcObject instanceof MediaStream)) return false; // srcObject is not a camera stream\n                stream = this.$video.srcObject;\n            } else {\n                stream = (await this._getCameraStream()).stream;\n            }\n            return 'torch' in stream.getVideoTracks()[0].getSettings();\n        } catch (e) {\n            return false;\n        } finally {\n            // close the stream we just opened for detecting whether it supports flash\n            if (stream && stream !== this.$video.srcObject) {\n                console.warn('Call hasFlash after successfully starting the scanner to avoid creating '\n                    + 'a temporary video stream');\n                QrScanner._stopVideoStream(stream);\n            }\n        }\n    }\n\n    isFlashOn(): boolean {\n        return this._flashOn;\n    }\n\n    async toggleFlash(): Promise<void> {\n        if (this._flashOn) {\n            await this.turnFlashOff();\n        } else {\n            await this.turnFlashOn();\n        }\n    }\n\n    async turnFlashOn(): Promise<void> {\n        if (this._flashOn || this._destroyed) return;\n        this._flashOn = true;\n        if (!this._active || this._paused) return; // flash will be turned on later on .start()\n        try {\n            if (!await this.hasFlash()) throw 'No flash available';\n            // Note that the video track is guaranteed to exist and to be a MediaStream due to the check in hasFlash\n            await (this.$video.srcObject as MediaStream).getVideoTracks()[0].applyConstraints({\n                // @ts-ignore: constraint 'torch' is unknown to ts\n                advanced: [{ torch: true }],\n            });\n        } catch (e) {\n            this._flashOn = false;\n            throw e;\n        }\n    }\n\n    async turnFlashOff(): Promise<void> {\n        if (!this._flashOn) return;\n        // applyConstraints with torch: false does not work to turn the flashlight off, as a stream's torch stays\n        // continuously on, see https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#torch. Therefore,\n        // we have to stop the stream to turn the flashlight off.\n        this._flashOn = false;\n        await this._restartVideoStream();\n    }\n\n    destroy(): void {\n        this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n        window.removeEventListener('resize', this._updateOverlay);\n\n        this._destroyed = true;\n        this._flashOn = false;\n        this.stop(); // sets this._paused = true and this._active = false\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\n    }\n\n    async start(): Promise<void> {\n        if (this._destroyed) throw new Error('The QR scanner can not be started as it had been destroyed.');\n        if (this._active && !this._paused) return;\n\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n\n        this._active = true;\n        if (document.hidden) return; // camera will be started as soon as tab is in foreground\n        this._paused = false;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            await this.$video.play();\n            return;\n        }\n\n        try {\n            const { stream, facingMode } = await this._getCameraStream();\n            if (!this._active || this._paused) {\n                // was stopped in the meantime\n                QrScanner._stopVideoStream(stream);\n                return;\n            }\n            this._setVideoMirror(facingMode);\n            this.$video.srcObject = stream;\n            await this.$video.play();\n\n            // Restart the flash if it was previously on\n            if (this._flashOn) {\n                this._flashOn = false; // force turnFlashOn to restart the flash\n                this.turnFlashOn().catch(() => {});\n            }\n        } catch (e) {\n            if (this._paused) return;\n            this._active = false;\n            throw e;\n        }\n    }\n\n    stop(): void {\n        this.pause();\n        this._active = false;\n    }\n\n    async pause(stopStreamImmediately = false): Promise<boolean> {\n        this._paused = true;\n        if (!this._active) return true;\n        this.$video.pause();\n\n        if (this.$overlay) {\n            this.$overlay.style.display = 'none';\n        }\n\n        const stopStream = () => {\n            if (this.$video.srcObject instanceof MediaStream) {\n                // revoke srcObject only if it's a stream which was likely set by us\n                QrScanner._stopVideoStream(this.$video.srcObject);\n                this.$video.srcObject = null;\n            }\n        };\n\n        if (stopStreamImmediately) {\n            stopStream();\n            return true;\n        }\n\n        await new Promise((resolve) => setTimeout(resolve, 300));\n        if (!this._paused) return false;\n        stopStream();\n        return true;\n    }\n\n    async setCamera(facingModeOrDeviceId: QrScanner.FacingMode | QrScanner.DeviceId): Promise<void> {\n        if (facingModeOrDeviceId === this._preferredCamera) return;\n        this._preferredCamera = facingModeOrDeviceId;\n        // Restart the scanner with the new camera which will also update the video mirror and the scan region.\n        await this._restartVideoStream();\n    }\n\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        options: {\n            scanRegion?: QrScanner.ScanRegion | null,\n            qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n            canvas?: HTMLCanvasElement | null,\n            disallowCanvasResizing?: boolean,\n            alsoTryWithoutScanRegion?: boolean,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n    ): Promise<QrScanner.ScanResult>;\n    /** @deprecated */\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        scanRegion?: QrScanner.ScanRegion | null,\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing?: boolean,\n        alsoTryWithoutScanRegion?: boolean,\n    ): Promise<string>;\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        scanRegionOrOptions?: QrScanner.ScanRegion | {\n            scanRegion?: QrScanner.ScanRegion | null,\n            qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n            canvas?: HTMLCanvasElement | null,\n            disallowCanvasResizing?: boolean,\n            alsoTryWithoutScanRegion?: boolean,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        } | null,\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing: boolean = false,\n        alsoTryWithoutScanRegion: boolean = false,\n    ): Promise<string | QrScanner.ScanResult> {\n        let scanRegion: QrScanner.ScanRegion | null | undefined;\n        let returnDetailedScanResult = false;\n        if (scanRegionOrOptions && (\n            'scanRegion' in scanRegionOrOptions\n            || 'qrEngine' in scanRegionOrOptions\n            || 'canvas' in scanRegionOrOptions\n            || 'disallowCanvasResizing' in scanRegionOrOptions\n            || 'alsoTryWithoutScanRegion' in scanRegionOrOptions\n            || 'returnDetailedScanResult' in scanRegionOrOptions\n        )) {\n            // we got an options object using the new api\n            scanRegion = scanRegionOrOptions.scanRegion;\n            qrEngine = scanRegionOrOptions.qrEngine;\n            canvas = scanRegionOrOptions.canvas;\n            disallowCanvasResizing = scanRegionOrOptions.disallowCanvasResizing || false;\n            alsoTryWithoutScanRegion = scanRegionOrOptions.alsoTryWithoutScanRegion || false;\n            returnDetailedScanResult = true;\n        } else if (scanRegionOrOptions || qrEngine || canvas || disallowCanvasResizing || alsoTryWithoutScanRegion) {\n            console.warn('You\\'re using a deprecated api for scanImage which will be removed in the future.');\n        } else {\n            // Only imageOrFileOrBlobOrUrl was specified and we can't distinguish between new or old api usage. For\n            // backwards compatibility we have to assume the old api for now. The options object is marked as non-\n            // optional in the parameter list above to make clear that ScanResult instead of string is only returned if\n            // an options object was provided. However, in the future once legacy support is removed, the options object\n            // should become optional.\n            console.warn('Note that the return type of scanImage will change in the future. To already switch to the '\n                + 'new api today, you can pass returnDetailedScanResult: true.');\n        }\n\n        const gotExternalEngine = !!qrEngine;\n\n        try {\n            let image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n                | SVGImageElement;\n            let canvasContext: CanvasRenderingContext2D;\n            [qrEngine, image] = await Promise.all([\n                qrEngine || QrScanner.createQrEngine(),\n                QrScanner._loadImage(imageOrFileOrBlobOrUrl),\n            ]);\n            [canvas, canvasContext] = QrScanner._drawToCanvas(image, scanRegion, canvas, disallowCanvasResizing);\n            let detailedScanResult: QrScanner.ScanResult;\n\n            if (qrEngine instanceof Worker) {\n                const qrEngineWorker = qrEngine; // for ts to know that it's still a worker later in the event listeners\n                if (!gotExternalEngine) {\n                    // Enable scanning of inverted color qr codes.\n                    QrScanner._postWorkerMessageSync(qrEngineWorker, 'inversionMode', 'both');\n                }\n                detailedScanResult = await new Promise((resolve, reject) => {\n                    let timeout: number;\n                    let onMessage: (event: MessageEvent) => void;\n                    let onError: (error: ErrorEvent | string) => void;\n                    let expectedResponseId = -1;\n                    onMessage = (event: MessageEvent) => {\n                        if (event.data.id !== expectedResponseId) {\n                            return;\n                        }\n                        qrEngineWorker.removeEventListener('message', onMessage);\n                        qrEngineWorker.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        if (event.data.data !== null) {\n                            resolve({\n                                data: event.data.data,\n                                cornerPoints: QrScanner._convertPoints(event.data.cornerPoints, scanRegion),\n                            });\n                        } else {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        }\n                    };\n                    onError = (error: ErrorEvent | string) => {\n                        qrEngineWorker.removeEventListener('message', onMessage);\n                        qrEngineWorker.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        const errorMessage = !error ? 'Unknown Error' : ((error as ErrorEvent).message || error);\n                        reject('Scanner error: ' + errorMessage);\n                    };\n                    qrEngineWorker.addEventListener('message', onMessage);\n                    qrEngineWorker.addEventListener('error', onError);\n                    timeout = setTimeout(() => onError('timeout'), 10000);\n                    const imageData = canvasContext.getImageData(0, 0, canvas!.width, canvas!.height);\n                    expectedResponseId = QrScanner._postWorkerMessageSync(\n                        qrEngineWorker,\n                        'decode',\n                        imageData,\n                        [imageData.data.buffer],\n                    );\n                });\n            } else {\n                detailedScanResult = await Promise.race([\n                    new Promise<QrScanner.ScanResult>((resolve, reject) => window.setTimeout(\n                        () => reject('Scanner error: timeout'),\n                        10000,\n                    )),\n                    (async (): Promise<QrScanner.ScanResult> => {\n                        try {\n                            const [scanResult] = await qrEngine.detect(canvas!);\n                            if (!scanResult) throw QrScanner.NO_QR_CODE_FOUND;\n                            return {\n                                data: scanResult.rawValue,\n                                cornerPoints: QrScanner._convertPoints(scanResult.cornerPoints, scanRegion),\n                            };\n                        } catch (e) {\n                            const errorMessage = (e as Error).message || e as string;\n                            if (/not implemented|service unavailable/.test(errorMessage)) {\n                                // Not implemented can apparently for some reason happen even though getSupportedFormats\n                                // in createQrScanner reported that it's supported, see issue #98.\n                                // Service unavailable can happen after some time when the BarcodeDetector crashed and\n                                // can theoretically be recovered from by creating a new BarcodeDetector. However, in\n                                // newer browsers this issue does not seem to be present anymore and therefore we do not\n                                // apply this optimization anymore but just set _disableBarcodeDetector in both cases.\n                                // Also note that if we got an external qrEngine that crashed, we should possibly notify\n                                // the caller about it, but we also don't do this here, as it's such an unlikely case.\n                                QrScanner._disableBarcodeDetector = true;\n                                // retry without passing the broken BarcodeScanner instance\n                                return QrScanner.scanImage(imageOrFileOrBlobOrUrl, {\n                                    scanRegion,\n                                    canvas,\n                                    disallowCanvasResizing,\n                                    alsoTryWithoutScanRegion,\n                                });\n                            }\n                            throw `Scanner error: ${errorMessage}`;\n                        }\n                    })(),\n                ]);\n            }\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\n        } catch (e) {\n            if (!scanRegion || !alsoTryWithoutScanRegion) throw e;\n            const detailedScanResult = await QrScanner.scanImage(\n                imageOrFileOrBlobOrUrl,\n                { qrEngine, canvas, disallowCanvasResizing },\n            );\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\n        } finally {\n            if (!gotExternalEngine) {\n                QrScanner._postWorkerMessage(qrEngine!, 'close');\n            }\n        }\n    }\n\n    setGrayscaleWeights(red: number, green: number, blue: number, useIntegerApproximation: boolean = true): void {\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\n        // implementations work also well with colored qr codes.\n        QrScanner._postWorkerMessage(\n            this._qrEnginePromise,\n            'grayscaleWeights',\n            { red, green, blue, useIntegerApproximation }\n        );\n    }\n\n    setInversionMode(inversionMode: QrScanner.InversionMode): void {\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\n        // implementations scan normal and inverted qr codes by default\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\n    }\n\n    static async createQrEngine(): Promise<Worker | BarcodeDetector>;\n    /** @deprecated */\n    static async createQrEngine(workerPath: string): Promise<Worker | BarcodeDetector>;\n    static async createQrEngine(workerPath?: string): Promise<Worker | BarcodeDetector> {\n        if (workerPath) {\n            console.warn('Specifying a worker path is not required and not supported anymore.');\n        }\n\n        // @ts-ignore no types defined for import\n        const createWorker = () => (import('./qr-scanner-worker.min.js') as Promise<{ createWorker: () => Worker }>)\n            .then((module) => module.createWorker());\n\n        const useBarcodeDetector = !QrScanner._disableBarcodeDetector\n            && 'BarcodeDetector' in window\n            && BarcodeDetector.getSupportedFormats\n            && (await BarcodeDetector.getSupportedFormats()).includes('qr_code');\n\n        if (!useBarcodeDetector) return createWorker();\n\n        // On Macs with an M1/M2 processor and macOS Ventura (macOS version 13), the BarcodeDetector is broken in\n        // Chromium based browsers, regardless of the version. For that constellation, the BarcodeDetector does not\n        // error but does not detect QR codes. Macs without an M1/M2 or before Ventura are fine.\n        // See issue #209 and https://bugs.chromium.org/p/chromium/issues/detail?id=1382442\n        // TODO update this once the issue in macOS is fixed\n        const userAgentData = navigator.userAgentData;\n        const isChromiumOnMacWithArmVentura = userAgentData // all Chromium browsers support userAgentData\n            && userAgentData.brands.some(({ brand }) => /Chromium/i.test(brand))\n            && /mac ?OS/i.test(userAgentData.platform)\n            // Does it have an ARM chip (e.g. M1/M2) and Ventura? Check this last as getHighEntropyValues can\n            // theoretically trigger a browser prompt, although no browser currently does seem to show one.\n            // If browser or user refused to return the requested values, assume broken ARM Ventura, to be safe.\n            && await userAgentData.getHighEntropyValues(['architecture', 'platformVersion'])\n                .then(({ architecture, platformVersion }) =>\n                    /arm/i.test(architecture || 'arm') && parseInt(platformVersion || '13') >= /* Ventura */ 13)\n                .catch(() => true);\n        if (isChromiumOnMacWithArmVentura) return createWorker();\n\n        return new BarcodeDetector({ formats: ['qr_code'] });\n    }\n\n    private _onPlay(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._updateOverlay();\n        if (this.$overlay) {\n            this.$overlay.style.display = '';\n        }\n        this._scanFrame();\n    }\n\n    private _onLoadedMetaData(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._updateOverlay();\n    }\n\n    private _onVisibilityChange(): void {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    private _calculateScanRegion(video: HTMLVideoElement): QrScanner.ScanRegion {\n        // Default scan region calculation. Note that this can be overwritten in the constructor.\n        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);\n        const scanRegionSize = Math.round(2 / 3 * smallestDimension);\n        return {\n            x: Math.round((video.videoWidth - scanRegionSize) / 2),\n            y: Math.round((video.videoHeight - scanRegionSize) / 2),\n            width: scanRegionSize,\n            height: scanRegionSize,\n            downScaledWidth: this._legacyCanvasSize,\n            downScaledHeight: this._legacyCanvasSize,\n        };\n    }\n\n    private _updateOverlay(): void {\n        requestAnimationFrame(() => {\n            // Running in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle\n            // and offsetWidth, offsetHeight, offsetLeft, offsetTop.\n            if (!this.$overlay) return;\n            const video = this.$video;\n            const videoWidth = video.videoWidth;\n            const videoHeight = video.videoHeight;\n            const elementWidth = video.offsetWidth;\n            const elementHeight = video.offsetHeight;\n            const elementX = video.offsetLeft;\n            const elementY = video.offsetTop;\n\n            const videoStyle = window.getComputedStyle(video);\n            const videoObjectFit = videoStyle.objectFit;\n            const videoAspectRatio = videoWidth / videoHeight;\n            const elementAspectRatio = elementWidth / elementHeight;\n            let videoScaledWidth: number;\n            let videoScaledHeight: number;\n            switch (videoObjectFit) {\n                case 'none':\n                    videoScaledWidth = videoWidth;\n                    videoScaledHeight = videoHeight;\n                    break;\n                case 'fill':\n                    videoScaledWidth = elementWidth;\n                    videoScaledHeight = elementHeight;\n                    break;\n                default: // 'cover', 'contains', 'scale-down'\n                    if (videoObjectFit === 'cover'\n                        ? videoAspectRatio > elementAspectRatio\n                        : videoAspectRatio < elementAspectRatio) {\n                        // The scaled height is the element height\n                        // - for 'cover' if the video aspect ratio is wider than the element aspect ratio\n                        //   (scaled height matches element height and scaled width overflows element width)\n                        // - for 'contains'/'scale-down' if element aspect ratio is wider than the video aspect ratio\n                        //   (scaled height matched element height and element width overflows scaled width)\n                        videoScaledHeight = elementHeight;\n                        videoScaledWidth = videoScaledHeight * videoAspectRatio;\n                    } else {\n                        videoScaledWidth = elementWidth;\n                        videoScaledHeight = videoScaledWidth / videoAspectRatio;\n                    }\n                    if (videoObjectFit === 'scale-down') {\n                        // for 'scale-down' the dimensions are the minimum of 'contains' and 'none'\n                        videoScaledWidth = Math.min(videoScaledWidth, videoWidth);\n                        videoScaledHeight = Math.min(videoScaledHeight, videoHeight);\n                    }\n            }\n\n            // getComputedStyle is so nice to convert keywords (left, center, right, top, bottom) to percent and makes\n            // sure to set the default of 50% if only one or no component was provided, therefore we can be sure that\n            // both components are set. Additionally, it converts units other than px (e.g. rem) to px.\n            const [videoX, videoY] = videoStyle.objectPosition.split(' ').map((length, i) => {\n                const lengthValue = parseFloat(length);\n                return length.endsWith('%')\n                    ? (!i ? elementWidth - videoScaledWidth : elementHeight - videoScaledHeight) * lengthValue / 100\n                    : lengthValue;\n            });\n\n            const regionWidth = this._scanRegion.width || videoWidth;\n            const regionHeight = this._scanRegion.height || videoHeight;\n            const regionX = this._scanRegion.x || 0;\n            const regionY = this._scanRegion.y || 0;\n\n            const overlayStyle = this.$overlay.style;\n            overlayStyle.width = `${regionWidth / videoWidth * videoScaledWidth}px`;\n            overlayStyle.height = `${regionHeight / videoHeight * videoScaledHeight}px`;\n            overlayStyle.top = `${elementY + videoY + regionY / videoHeight * videoScaledHeight}px`;\n            const isVideoMirrored = /scaleX\\(-1\\)/.test(video.style.transform!);\n            overlayStyle.left = `${elementX\n                + (isVideoMirrored ? elementWidth - videoX - videoScaledWidth : videoX)\n                + (isVideoMirrored ? videoWidth - regionX - regionWidth : regionX) / videoWidth * videoScaledWidth}px`;\n            // apply same mirror as on video\n            overlayStyle.transform = video.style.transform;\n        });\n    }\n\n    private static _convertPoints(\n        points: QrScanner.Point[],\n        scanRegion?: QrScanner.ScanRegion | null,\n    ): QrScanner.Point[] {\n        if (!scanRegion) return points;\n        const offsetX = scanRegion.x || 0;\n        const offsetY = scanRegion.y || 0;\n        const scaleFactorX = scanRegion.width && scanRegion.downScaledWidth\n            ? scanRegion.width / scanRegion.downScaledWidth\n            : 1;\n        const scaleFactorY = scanRegion.height && scanRegion.downScaledHeight\n            ? scanRegion.height / scanRegion.downScaledHeight\n            : 1;\n        for (const point of points) {\n            point.x = point.x * scaleFactorX + offsetX;\n            point.y = point.y * scaleFactorY + offsetY;\n        }\n        return points;\n    }\n\n    private _scanFrame(): void {\n        if (!this._active || this.$video.paused || this.$video.ended) return;\n        // If requestVideoFrameCallback is available use that to avoid unnecessary scans on the same frame as the\n        // camera's framerate can be lower than the screen refresh rate and this._maxScansPerSecond, especially in dark\n        // settings where the exposure time is longer. Both, requestVideoFrameCallback and requestAnimationFrame are not\n        // being fired if the tab is in the background, which is what we want.\n        const requestFrame = 'requestVideoFrameCallback' in this.$video\n            // @ts-ignore\n            ? this.$video.requestVideoFrameCallback.bind(this.$video)\n            : requestAnimationFrame;\n        requestFrame(async () => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n\n            const timeSinceLastScan = Date.now() - this._lastScanTimestamp;\n            const minimumTimeBetweenScans = 1000 / this._maxScansPerSecond;\n            if (timeSinceLastScan < minimumTimeBetweenScans) {\n                await new Promise((resolve) => setTimeout(resolve, minimumTimeBetweenScans - timeSinceLastScan));\n            }\n            // console.log('Scan rate:', Math.round(1000 / (Date.now() - this._lastScanTimestamp)));\n            this._lastScanTimestamp = Date.now();\n\n            let result: QrScanner.ScanResult | undefined;\n            try {\n                result = await QrScanner.scanImage(this.$video, {\n                    scanRegion: this._scanRegion,\n                    qrEngine: this._qrEnginePromise,\n                    canvas: this.$canvas,\n                });\n            } catch (error) {\n                if (!this._active) return;\n                this._onDecodeError(error as Error | string);\n            }\n\n            if (QrScanner._disableBarcodeDetector && !(await this._qrEnginePromise instanceof Worker)) {\n                // replace the disabled BarcodeDetector\n                this._qrEnginePromise = QrScanner.createQrEngine();\n            }\n\n            if (result) {\n                if (this._onDecode) {\n                    this._onDecode(result);\n                } else if (this._legacyOnDecode) {\n                    this._legacyOnDecode(result.data);\n                }\n\n                if (this.$codeOutlineHighlight) {\n                    clearTimeout(this._codeOutlineHighlightRemovalTimeout);\n                    this._codeOutlineHighlightRemovalTimeout = undefined;\n                    this.$codeOutlineHighlight.setAttribute(\n                        'viewBox',\n                        `${this._scanRegion.x || 0} `\n                            + `${this._scanRegion.y || 0} `\n                            + `${this._scanRegion.width || this.$video.videoWidth} `\n                            + `${this._scanRegion.height || this.$video.videoHeight}`,\n                    );\n                    const polygon = this.$codeOutlineHighlight.firstElementChild!;\n                    polygon.setAttribute('points', result.cornerPoints.map(({x, y}) => `${x},${y}`).join(' '));\n                    this.$codeOutlineHighlight.style.display = '';\n                }\n            } else if (this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout) {\n                // hide after timeout to make it flash less when on some frames the QR code is detected and on some not\n                this._codeOutlineHighlightRemovalTimeout = setTimeout(\n                    () => this.$codeOutlineHighlight!.style.display = 'none',\n                    100,\n                );\n            }\n\n            this._scanFrame();\n        });\n    }\n\n    private _onDecodeError(error: Error | string): void {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    private async _getCameraStream(): Promise<{ stream: MediaStream, facingMode: QrScanner.FacingMode }> {\n        if (!navigator.mediaDevices) throw 'Camera not found.';\n\n        const preferenceType = /^(environment|user)$/.test(this._preferredCamera)\n            ? 'facingMode'\n            : 'deviceId';\n        const constraintsWithoutCamera: Array<MediaTrackConstraints> = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n        const constraintsWithCamera = constraintsWithoutCamera.map((constraint) => Object.assign({}, constraint, {\n            [preferenceType]: { exact: this._preferredCamera },\n        }));\n\n        for (const constraints of [...constraintsWithCamera, ...constraintsWithoutCamera]) {\n            try {\n                const stream = await navigator.mediaDevices.getUserMedia({ video: constraints, audio: false });\n                // Try to determine the facing mode from the stream, otherwise use a guess or 'environment' as\n                // default. Note that the guess is not always accurate as Safari returns cameras of different facing\n                // mode, even for exact facingMode constraints.\n                const facingMode = this._getFacingMode(stream)\n                    || (constraints.facingMode\n                        ? this._preferredCamera as QrScanner.FacingMode // a facing mode we were able to fulfill\n                        : (this._preferredCamera === 'environment'\n                            ? 'user' // switch as _preferredCamera was environment but we are not able to fulfill it\n                            : 'environment' // switch from unfulfilled user facingMode or default to environment\n                        )\n                    );\n                return { stream, facingMode };\n            } catch (e) {}\n        }\n\n        throw 'Camera not found.';\n    }\n\n    private async _restartVideoStream(): Promise<void> {\n        // Note that we always pause the stream and not only if !this._paused as even if this._paused === true, the\n        // stream might still be running, as it's by default only stopped after a delay of 300ms.\n        const wasPaused = this._paused;\n        const paused = await this.pause(true);\n        if (!paused || wasPaused || !this._active) return;\n        await this.start();\n    }\n\n    private static _stopVideoStream(stream : MediaStream): void {\n        for (const track of stream.getTracks()) {\n            track.stop(); //  note that this will also automatically turn the flashlight off\n            stream.removeTrack(track);\n        }\n    }\n\n    private _setVideoMirror(facingMode: QrScanner.FacingMode): void {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode === 'user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    private _getFacingMode(videoStream: MediaStream): QrScanner.FacingMode | null {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    private static _drawToCanvas(\n        image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement,\n        scanRegion?: QrScanner.ScanRegion | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing= false,\n    ): [HTMLCanvasElement, CanvasRenderingContext2D] {\n        canvas = canvas || document.createElement('canvas');\n        const scanRegionX = scanRegion && scanRegion.x ? scanRegion.x : 0;\n        const scanRegionY = scanRegion && scanRegion.y ? scanRegion.y : 0;\n        const scanRegionWidth = scanRegion && scanRegion.width\n            ? scanRegion.width\n            : (image as HTMLVideoElement).videoWidth || image.width as number;\n        const scanRegionHeight = scanRegion && scanRegion.height\n            ? scanRegion.height\n            : (image as HTMLVideoElement).videoHeight || image.height as number;\n\n        if (!disallowCanvasResizing) {\n            const canvasWidth = scanRegion && scanRegion.downScaledWidth\n                ? scanRegion.downScaledWidth\n                : scanRegionWidth;\n            const canvasHeight = scanRegion && scanRegion.downScaledHeight\n                ? scanRegion.downScaledHeight\n                : scanRegionHeight;\n            // Setting the canvas width or height clears the canvas, even if the values didn't change, therefore only\n            // set them if they actually changed.\n            if (canvas.width !== canvasWidth) {\n                canvas.width = canvasWidth;\n            }\n            if (canvas.height !== canvasHeight) {\n                canvas.height = canvasHeight;\n            }\n        }\n\n        const context = canvas.getContext('2d', { alpha: false })!;\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(\n            image,\n            scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight,\n            0, 0, canvas.width, canvas.height,\n        );\n        return [canvas, context];\n    }\n\n    private static async _loadImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n    ): Promise<HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n        | SVGImageElement > {\n        if (imageOrFileOrBlobOrUrl instanceof Image) {\n            await QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl);\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement\n            || imageOrFileOrBlobOrUrl instanceof SVGImageElement\n            || 'OffscreenCanvas' in window && imageOrFileOrBlobOrUrl instanceof OffscreenCanvas\n            || 'ImageBitmap' in window && imageOrFileOrBlobOrUrl instanceof ImageBitmap) {\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof imageOrFileOrBlobOrUrl === 'string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl.toString();\n            }\n            try {\n                await QrScanner._awaitImageLoad(image);\n                return image;\n            } finally {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n            }\n        } else {\n            throw 'Unsupported image type.';\n        }\n    }\n\n    private static async _awaitImageLoad(image: HTMLImageElement): Promise<void> {\n        if (image.complete && image.naturalWidth !== 0) return; // already loaded\n        await new Promise<void>((resolve, reject) => {\n            const listener = (event: ErrorEvent | Event) => {\n                image.removeEventListener('load', listener);\n                image.removeEventListener('error', listener);\n                if (event instanceof ErrorEvent) {\n                    reject('Image load error');\n                } else {\n                    resolve();\n                }\n            };\n            image.addEventListener('load', listener);\n            image.addEventListener('error', listener);\n        });\n    }\n\n    private static async _postWorkerMessage(\n        qrEngineOrQrEnginePromise: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector>,\n        type: string,\n        data?: any,\n        transfer?: Transferable[],\n    ): Promise<number> {\n        return QrScanner._postWorkerMessageSync(await qrEngineOrQrEnginePromise, type, data, transfer);\n    }\n\n    // sync version of _postWorkerMessage without performance overhead of async functions\n    private static _postWorkerMessageSync(\n        qrEngine: Worker | BarcodeDetector,\n        type: string,\n        data?: any,\n        transfer?: Transferable[],\n    ): number {\n        if (!(qrEngine instanceof Worker)) return -1;\n        const id = QrScanner._workerMessageId++;\n        qrEngine.postMessage({\n            id,\n            type,\n            data,\n        }, transfer);\n        return id;\n    }\n}\n\ndeclare namespace QrScanner {\n    export interface ScanRegion {\n        x?: number;\n        y?: number;\n        width?: number;\n        height?: number;\n        downScaledWidth?: number;\n        downScaledHeight?: number;\n    }\n\n    export type FacingMode = 'environment' | 'user';\n    export type DeviceId = string;\n\n    export interface Camera {\n        id: DeviceId;\n        label: string;\n    }\n\n    export type InversionMode = 'original' | 'invert' | 'both';\n\n    export interface Point {\n        x: number;\n        y: number;\n    }\n\n    export interface ScanResult {\n        data: string;\n        // In clockwise order, starting at top left, but this might not be guaranteed in the future.\n        cornerPoints: QrScanner.Point[];\n    }\n}\n\n// simplified from https://wicg.github.io/shape-detection-api/#barcode-detection-api\ndeclare class BarcodeDetector {\n    constructor(options?: { formats: string[] });\n    static getSupportedFormats(): Promise<string[]>;\n    detect(image: ImageBitmapSource): Promise<Array<{ rawValue: string, cornerPoints: QrScanner.Point[] }>>;\n}\n\n// simplified from https://github.com/lukewarlow/user-agent-data-types/blob/master/index.d.ts\ndeclare global {\n    interface Navigator {\n        readonly userAgentData?: {\n            readonly platform: string;\n            readonly brands: Array<{\n                readonly brand: string;\n                readonly version: string;\n            }>;\n            getHighEntropyValues(hints: string[]): Promise<{\n                readonly architecture?: string;\n                readonly platformVersion?: string;\n            }>;\n        };\n    }\n}\n\nexport default QrScanner;\n","class CountryList {\n  constructor() {\n    this.data = require('./data.json')\n    this.labelMap = {}\n    this.valueMap = {}\n\n    this.data.forEach(country => {\n      this.labelMap[country.label.toLowerCase()] = country.value\n      this.valueMap[country.value.toLowerCase()] = country.label\n    })\n  }\n\n  getValue(label) {\n    return this.labelMap[label.toLowerCase()]\n  }\n\n  getLabel(value) {\n    return this.valueMap[value.toLowerCase()]\n  }\n\n  getLabels() {\n    return this.data.map(country => country.label)\n  }\n\n  getValues() {\n    return this.data.map(country => country.value)\n  }\n\n  getLabelList() {\n    return this.labelMap\n  }\n\n  getValueList() {\n    return this.valueMap\n  }\n\n  getData() {\n    return this.data\n  }\n\n  setLabel(value, label) {\n    this.data.forEach(country => {\n      if (country.value === value) {\n        country.label = label\n        this.valueMap[country.value.toLowerCase()] = country.label\n      }\n    })\n\n    return this\n  }\n\n  setEmpty(label) {\n    this.data.unshift({\n      value: '',\n      label: label,\n    })\n    this.valueMap[''] = label\n    this.labelMap[label] = ''\n\n    return this\n  }\n\n  native() {\n    this.nativeData = require('./data-native.json')\n    this.nativeData.forEach(country => {\n      this.labelMap[country.label.toLowerCase()] = country.value\n      this.valueMap[country.value.toLowerCase()] = country.label\n    })\n\n    return this\n  }\n}\n\nconst countryList = () => {\n  if (!(this instanceof CountryList)) return new CountryList()\n}\n\nmodule.exports = countryList\n","import * as React from \"rehackt\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport type {\n  MutationFunctionOptions,\n  MutationHookOptions,\n  MutationResult,\n  MutationTuple,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport type {\n  ApolloCache,\n  DefaultContext,\n  MutationOptions,\n  OperationVariables,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\n/**\n *\n *\n * > Refer to the [Mutations](https://www.apollographql.com/docs/react/data/mutations/) section for a more in-depth overview of `useMutation`.\n *\n * @example\n * ```jsx\n * import { gql, useMutation } from '@apollo/client';\n *\n * const ADD_TODO = gql`\n *   mutation AddTodo($type: String!) {\n *     addTodo(type: $type) {\n *       id\n *       type\n *     }\n *   }\n * `;\n *\n * function AddTodo() {\n *   let input;\n *   const [addTodo, { data }] = useMutation(ADD_TODO);\n *\n *   return (\n *     <div>\n *       <form\n *         onSubmit={e => {\n *           e.preventDefault();\n *           addTodo({ variables: { type: input.value } });\n *           input.value = '';\n *         }}\n *       >\n *         <input\n *           ref={node => {\n *             input = node;\n *           }}\n *         />\n *         <button type=\"submit\">Add Todo</button>\n *       </form>\n *     </div>\n *   );\n * }\n * ```\n * @since 3.0.0\n * @param mutation - A GraphQL mutation document parsed into an AST by `gql`.\n * @param options - Options to control how the mutation is executed.\n * @returns A tuple in the form of `[mutate, result]`\n */\nexport function useMutation<\n  TData = any,\n  TVariables = OperationVariables,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: MutationHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>,\n    TContext,\n    TCache\n  >\n): MutationTuple<TData, TVariables, TContext, TCache> {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(mutation, DocumentType.Mutation);\n  const [result, setResult] = React.useState<Omit<MutationResult, \"reset\">>({\n    called: false,\n    loading: false,\n    client,\n  });\n\n  const ref = React.useRef({\n    result,\n    mutationId: 0,\n    isMounted: true,\n    client,\n    mutation,\n    options,\n  });\n\n  // TODO: Trying to assign these in a useEffect or useLayoutEffect breaks\n  // higher-order components.\n  {\n    Object.assign(ref.current, { client, options, mutation });\n  }\n\n  const execute = React.useCallback(\n    (\n      executeOptions: MutationFunctionOptions<\n        TData,\n        TVariables,\n        TContext,\n        TCache\n      > = {}\n    ) => {\n      const { options, mutation } = ref.current;\n      const baseOptions = { ...options, mutation };\n      const client = executeOptions.client || ref.current.client;\n\n      if (\n        !ref.current.result.loading &&\n        !baseOptions.ignoreResults &&\n        ref.current.isMounted\n      ) {\n        setResult(\n          (ref.current.result = {\n            loading: true,\n            error: void 0,\n            data: void 0,\n            called: true,\n            client,\n          })\n        );\n      }\n\n      const mutationId = ++ref.current.mutationId;\n      const clientOptions = mergeOptions(baseOptions, executeOptions);\n\n      return client\n        .mutate(clientOptions as MutationOptions<TData, OperationVariables>)\n        .then((response) => {\n          const { data, errors } = response;\n          const error =\n            errors && errors.length > 0 ?\n              new ApolloError({ graphQLErrors: errors })\n            : void 0;\n\n          const onError =\n            executeOptions.onError || ref.current.options?.onError;\n\n          if (error && onError) {\n            onError(\n              error,\n              clientOptions as MutationOptions<TData, OperationVariables>\n            );\n          }\n\n          if (\n            mutationId === ref.current.mutationId &&\n            !clientOptions.ignoreResults\n          ) {\n            const result = {\n              called: true,\n              loading: false,\n              data,\n              error,\n              client,\n            };\n\n            if (ref.current.isMounted && !equal(ref.current.result, result)) {\n              setResult((ref.current.result = result));\n            }\n          }\n\n          const onCompleted =\n            executeOptions.onCompleted || ref.current.options?.onCompleted;\n\n          if (!error) {\n            onCompleted?.(\n              response.data!,\n              clientOptions as MutationOptions<TData, OperationVariables>\n            );\n          }\n\n          return response;\n        })\n        .catch((error) => {\n          if (mutationId === ref.current.mutationId && ref.current.isMounted) {\n            const result = {\n              loading: false,\n              error,\n              data: void 0,\n              called: true,\n              client,\n            };\n\n            if (!equal(ref.current.result, result)) {\n              setResult((ref.current.result = result));\n            }\n          }\n\n          const onError =\n            executeOptions.onError || ref.current.options?.onError;\n\n          if (onError) {\n            onError(\n              error,\n              clientOptions as MutationOptions<TData, OperationVariables>\n            );\n\n            // TODO(brian): why are we returning this here???\n            return { data: void 0, errors: error };\n          }\n\n          throw error;\n        });\n    },\n    []\n  );\n\n  const reset = React.useCallback(() => {\n    if (ref.current.isMounted) {\n      const result = { called: false, loading: false, client };\n      Object.assign(ref.current, { mutationId: 0, result });\n      setResult(result);\n    }\n  }, []);\n\n  React.useEffect(() => {\n    ref.current.isMounted = true;\n\n    return () => {\n      ref.current.isMounted = false;\n    };\n  }, []);\n\n  return [execute, { reset, ...result }];\n}\n"],"names":["getCircularProgressUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_templateObject","_templateObject2","_templateObject3","_templateObject4","_excluded","_t","_t2","_t3","_t4","SIZE","circularRotateKeyframe","keyframes","_taggedTemplateLiteral","circularDashKeyframe","CircularProgressRoot","styled","name","overridesResolver","props","styles","ownerState","root","variant","concat","capitalize","color","_ref","theme","_extends","display","transition","transitions","create","vars","palette","main","_ref2","css","CircularProgressSVG","svg","CircularProgressCircle","circle","disableShrink","circleDisableShrink","_ref3","stroke","strokeDasharray","strokeDashoffset","_ref4","React","inProps","ref","useThemeProps","className","size","style","thickness","value","other","_objectWithoutPropertiesLoose","classes","slots","composeClasses","useUtilityClasses","circleStyle","rootStyle","rootProps","circumference","Math","PI","toFixed","round","transform","_jsx","clsx","width","height","role","children","viewBox","cx","cy","r","fill","strokeWidth","a","b","c","d","f","_legacyCanvasSize","e","DEFAULT_CANVAS_SIZE","_preferredCamera","_maxScansPerSecond","_lastScanTimestamp","_destroyed","_flashOn","_paused","_active","$video","this","$canvas","document","createElement","_onDecode","console","warn","_legacyOnDecode","_onDecodeError","onDecodeError","_calculateScanRegion","calculateScanRegion","preferredCamera","maxScansPerSecond","_onPlay","bind","_onLoadedMetaData","_onVisibilityChange","_updateOverlay","disablePictureInPicture","playsInline","muted","h","hidden","body","contains","appendChild","parentElement","highlightScanRegion","highlightCodeOutline","overlay","$overlay","position","pointerEvents","classList","add","innerHTML","firstElementChild","animate","duration","iterations","Infinity","direction","easing","m","insertBefore","nextSibling","insertAdjacentHTML","$codeOutlineHighlight","lastElementChild","_scanRegion","requestAnimationFrame","window","getComputedStyle","setProperty","visibility","opacity","removeChild","addEventListener","_qrEnginePromise","createQrEngine","WORKER_PATH","hasCamera","listCameras","length","arguments","undefined","navigator","mediaDevices","enumerateDevices","filter","kind","every","label","getUserMedia","audio","video","map","id","deviceId","_stopVideoStream","hasFlash","srcObject","MediaStream","_getCameraStream","stream","getVideoTracks","getSettings","isFlashOn","toggleFlash","turnFlashOff","turnFlashOn","applyConstraints","advanced","torch","_restartVideoStream","destroy","removeEventListener","stop","_postWorkerMessage","start","Error","location","protocol","play","facingMode","_setVideoMirror","catch","pause","Promise","setTimeout","setCamera","scanImage","n","scanRegion","qrEngine","canvas","disallowCanvasResizing","alsoTryWithoutScanRegion","p","k","q","all","_loadImage","_drawToCanvas","Worker","g","_postWorkerMessageSync","l","v","w","u","y","t","data","clearTimeout","cornerPoints","_convertPoints","NO_QR_CODE_FOUND","x","getImageData","buffer","race","detect","rawValue","message","test","_disableBarcodeDetector","setGrayscaleWeights","red","green","blue","useIntegerApproximation","setInversionMode","then","createWorker","BarcodeDetector","getSupportedFormats","includes","userAgentData","brands","some","brand","platform","getHighEntropyValues","architecture","platformVersion","parseInt","formats","_scanFrame","min","videoWidth","videoHeight","downScaledWidth","downScaledHeight","offsetWidth","offsetHeight","offsetLeft","objectFit","objectPosition","split","parseFloat","endsWith","top","left","paused","ended","requestVideoFrameCallback","async","readyState","Date","now","_codeOutlineHighlightRemovalTimeout","setAttribute","join","log","Object","assign","exact","_getFacingMode","getTracks","removeTrack","getContext","alpha","imageSmoothingEnabled","drawImage","Image","_awaitImageLoad","HTMLVideoElement","HTMLCanvasElement","SVGImageElement","OffscreenCanvas","ImageBitmap","File","Blob","URL","src","createObjectURL","toString","revokeObjectURL","complete","naturalWidth","ErrorEvent","_workerMessageId","postMessage","type","CountryList","constructor","require","labelMap","valueMap","forEach","country","toLowerCase","getValue","getLabel","getLabels","getValues","getLabelList","getValueList","getData","setLabel","setEmpty","unshift","native","nativeData","module","exports","countryList","useMutation","mutation","options","client","useApolloClient","verifyDocumentType","DocumentType","Mutation","_a","called","loading","result","setResult","mutationId","isMounted","current","execute","executeOptions","baseOptions","__assign","ignoreResults","error","clientOptions","mergeOptions","mutate","response","errors","ApolloError","graphQLErrors","onError","result_1","equal","onCompleted","_b","result_2","reset","result_3"],"sourceRoot":""}